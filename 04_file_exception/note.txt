文件操作 + 异常处理 整体介绍与详解
一、 整体介绍
(1) What（是什么）
    文件操作 + 异常处理是 Python 进行外部数据持久化和程序健壮性保障的两大核心机制的组合：
        文件操作：通过 open/read/write 实现程序与磁盘文件的双向数据交换
        异常处理：通过 try/except/finally 捕获并应对文件操作中可能出现的各类错误
        with 上下文：作为桥梁，将文件操作与异常处理结合，实现自动化资源管理
        关系：文件操作是目标，异常处理是防御，with 是最佳实践，三者共同构成工程级文件处理的标准范式。
(2) Why（为什么需要组合使用）
    单独文件操作的问题：
        文件可能不存在、无权限、被占用，导致程序崩溃
        忘记关闭文件会导致资源泄漏，长期运行耗尽系统句柄
        写入中途断电/报错，数据丢失或损坏，无法恢复
    组合的价值：
        健壮性：try/except 捕获 FileNotFoundError 等异常，让程序优雅降级（提示用户、记录日志）而非崩溃
        安全性：with 确保无论成功失败，文件一定关闭，防止资源泄漏
        可维护性：finally 清理临时资源，代码结构清晰，异常路径与正常路径分离
        数据完整性：with 的自动 flush 机制确保缓冲区数据落盘，降低丢失风险
        工程现实：生产环境绝不能出现裸 open()，必须用 with 包裹；任何文件操作都必须假设会失败，用 try/except 兜底。
(3) How（怎么用）
    标准范式：
    # 工程级文件读写模板
    try:
        with open('file.txt', 'r') as f:  # with 自动管理关闭
            content = f.read()  # 读取操作
            # 处理逻辑
    except FileNotFoundError:
        print("文件不存在")  # 异常处理
    except PermissionError:
        print("权限不足")
    finally:
        print("清理非文件资源")  # 最终清理
    使用原则：
    优先 with：所有文件操作默认用 with
    必须 try：任何 with 块外层包裹 try（除非是临时脚本）
    精确 except：捕获具体异常类型，最后可用 Exception 兜底
    清理放 finally：无论是否异常都要释放的资源（锁、网络连接）放 finally

二、 具体内容详解
1. 文件操作：open / read / write
（1）What（是什么）
    open()  ：打开文件的网关函数，在程序与文件之间建立连接通道。需指定文件名和模式（只读/只写/追加/二进制），返回文件对象。
    read()  ：从文件对象中一次性或分块提取内容，将字节流解码为字符串（文本模式）或返回原始字节（二进制模式）。读取指针会随之移动。
    write()  ：将字符串或字节写入文件缓冲区，内容需调用 flush() 或关闭文件才能真正落盘到磁盘。
（2）Why（为什么）
    数据持久化：程序内存中的变量在进程结束后消失，文件操作将数据写入磁盘实现永久保存
    数据交换：程序需要读取配置文件、日志、用户数据等外部输入，文件是跨系统、跨语言的通用数据载体
    流式处理：大文件无法一次性载入内存，read() 支持分块读取，实现内存友好的流式处理
    模式隔离：不同模式（读/写/追加）防止误操作，只读模式避免意外覆盖重要文件
（3）How（怎么用）
    open() 路径处理  ：优先使用绝对路径或 pathlib.Path 对象，避免相对路径因执行目录不同而失效
    模式选择  ：读取用 'r'（默认），覆盖写入用 'w'，追加用 'a'，二进制用 'rb'/'wb'
    读取策略  ：小文件用 read() 一次性读，大文件用循环配合 read(size) 或 readline() 逐行/逐块处理
    写入注意  ：'w' 模式会清空原文件，确认无误再使用；写入后必须关闭文件，否则数据可能丢失或损坏

2. with 上下文管理
（1）What（是什么）
    with 是 Python 的资源管理协议，自动处理资源的获取和释放。对文件操作而言，它确保文件在使用后一定被关闭，无论代码块正常结束还是发生异常。
    本质：with 调用对象的 __enter__() 方法进入上下文，代码块结束后调用 __exit__() 方法清理资源。
（2）Why（为什么）
    防止资源泄漏：手动 open() 后忘记 close() 会导致文件句柄占用，长期运行可能耗尽系统资源
    异常安全：try/finally 可确保关闭，但代码冗余；with 自动处理正常和异常路径，简洁且万无一失
    可读性提升：资源的生命周期被显式圈定在 with 块内，阅读时一目了然
    标准化：不仅文件，锁、网络连接、数据库事务等都支持 with，统一了资源管理模式
（3）How（怎么用）
    自动关闭：在 with 块内操作文件对象，块结束后文件自动关闭，无需手动调用 close()
    嵌套使用：多个资源可同时管理，用逗号分隔，with open() as f1, open() as f2
    自定义上下文：类实现 __enter__ 和 __exit__ 方法后也能用 with，例如计时器、事务管理器
    作用域限制：文件对象只在 with 块内有效，块外访问会触发已关闭异常，强制规范代码结构

3. 异常处理：try / except / finally
（1）What（是什么）
    try  ：包裹可能出错的代码块，Python 会监控其执行，一旦发生异常立即中断并跳转到 except
    except  ：捕获特定异常类型并处理，可捕获多种异常，也可捕获所有异常的基类 Exception。捕获后程序不会崩溃，而是执行 except 内的补救逻辑
    finally  ：无论是否发生异常，必定执行的清理代码块。常用于释放资源、关闭文件、还原状态，确保不因异常而遗漏关键操作
（2）Why（为什么）
    程序健壮性：异常未被捕获会导致整个进程终止，try/except 让程序在错误后优雅降级（如记录日志、返回默认值）而非崩溃
    错误分类处理：不同异常类型（文件不存在、权限不足、网络超时）需要差异化处理，多个 except 可精准响应
    资源最终释放：finally 确保无论成功失败，锁定文件、网络连接、临时状态都能被清理，避免死锁或泄漏
    调试信息：except 块可记录异常详情（traceback），帮助定位问题，同时向用户展示友好提示而非技术堆栈
（3）How（怎么用）
    精确捕获：优先捕获具体异常类型（如 FileNotFoundError），最后用 Exception 兜底，避免隐藏未知 Bug
    不要捕获所有异常：裸 except: 会捕获系统退出、键盘中断等致命异常，导致无法终止程序
    finally 只放清理代码：不在 finally 中写业务逻辑，只放 close()、unlock() 等释放操作
    上下文管理器优于 try/finally：文件操作优先用 with，更简洁；try/finally 用于无法使用 with 的复杂资源管理
    异常传递：若 except 中无法处理，用 raise 重新抛出异常，让上层调用者决定如何处理，避免静默吞掉错误