What：集合是什么？
    集合是无序、不重复的元素集，用花括号 {} 或 set() 创建。核心特征是唯一性：同一个元素
在集合中只存在一次，多次添加会自动去重。
    与列表的本质区别：
    列表关心顺序和重复（[1, 2, 2] 合法）
    集合只关心存在与否（{1, 2, 2} 自动变为 {1, 2}）
Why：为什么要用集合？
    去重是数据清洗的第一道工序：从用户输入、日志文件、API 响应中拿到的数据往往含大量重复，
集合提供O(1)时间复杂度的成员检测，效率远高于列表遍历。
    集合运算让逻辑更简洁：并集、交集、差集对应现实中的"合并权限""筛选共同好友""排除已处理
项"等场景，用集合运算一行代码顶循环十行。

1. 去重
(1)What（是什么）
    将可迭代对象（列表、元组、字符串）转换为集合，自动丢弃重复值，保留唯一元素。
(2)Why（为什么）
    手动写循环去重需要维护临时列表和 if x not in temp 判断，不仅代码冗余，时间复杂度为
O(n²)。集合底层是哈希表，去重过程自动完成，时间复杂度优化到 O(n)。
(3)How（怎么用）
    将需要去重的数据结构直接传入 set() 构造函数，转换后得到的集合只含唯一值。若需保持原顺
序，可再用有序结构（如列表）承接结果。
    典型场景：统计独立访客 ID、提取文章关键词、清洗重复提交的数据。

2. 并集：|
(1)What（是什么）
    取两个集合的所有元素，重复元素只保留一份。符号 | 表达的是"或"的语义——属于 A 或 B。
(2)Why（为什么）
    合并两组权限、整合多个数据源、汇总标签时，并集运算直接得到"全量集合"，无需手动循环添加和
去重。代码意图一目了然，符合数学直觉。
(3)How（怎么用）
    将两个集合用 | 连接，返回新集合。此操作不修改原集合，而是生成并集视图。若需就地更新，可用
 update() 方法。
    典型场景：合并用户角色权限、整合多个推荐系统的结果集、汇总多日的活跃用户。

3. 交集：&
(1)What（是什么）
    取两个集合的共有元素。符号 & 表达"与"的语义——同时属于 A 和 B。
(2)Why（为什么）
    筛选"共同好友""同时在线用户""两个条件都满足的标签"时，用循环需要嵌套遍历，效率低下。交集运
算是集合的核心价值，时间复杂度 O(min(len(A), len(B)))，直接定位共同元素。
(3)How（怎么用）
    将两个集合用 & 连接，返回新集合。结果集是两个集合的重叠部分。若结果为空集，说明两集合无交集。
    典型场景：找出两个部门的共同成员、筛选同时满足多标签的商品、分析用户兴趣重叠。

4. 差集：-
(1)What（是什么）
    取属于 A 但不属于 B的元素。符号 - 表达减法语义——从 A 中去掉 B 包含的内容。
(2)Why（为什么）
    业务中常需"排除已处理项""计算新增量""权限回收"等场景。用列表实现需双重循环判断，集合的差集
运算直接得到"剩余部分"，逻辑清晰且高效。
(3)How（怎么用）
    A - B 返回 A 中独有的元素。注意方向性：A - B 和 B - A 结果不同。若需修改原集合，可用
difference_update() 方法。
    典型场景：统计新增用户（今日集合 - 昨日集合）、清理无效标签、权限回收（总权限 - 禁用权限）。

5. 添加、删除元素
（1）What（是什么）
    向集合中插入新元素或移除已有元素。由于集合无序，添加不保证位置，删除也不影响其他元素顺序。
（2）Why（为什么）
    集合是动态容器，数据流处理中需要实时增删。例如实时筛选在线用户，用户上线添加到集合，下线移除。
集合的增删操作时间复杂度为 O(1)，且自动维护唯一性，无需手动检查重复。
（3）How（怎么用）
    添加：使用 add() 方法，传入单个元素。若元素已存在，操作静默失败，不报错也不修改集合。
    删除：使用 remove() 删除指定元素（元素不存在会报错），或使用 discard() 安全删除（元素不
存在不报错）。批量删除可用 clear() 清空集合。
    重要约束：只能添加**可哈希（不可变）**的元素，如数字、字符串、元组。列表、字典等可变对象无法
加入集合，也无法作为集合的元素参与运算。
    典型场景：维护实时在线用户列表、动态标签系统、黑名单/白名单管理。